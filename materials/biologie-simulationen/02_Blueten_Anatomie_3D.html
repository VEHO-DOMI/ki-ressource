<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bl√ºten-Anatomie</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 25px 30px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            z-index: 100;
        }

        h1 {
            font-size: 1.8em;
            font-weight: 700;
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: rgba(255,255,255,0.5);
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* View Toggle */
        .view-toggle {
            position: fixed;
            top: 25px;
            right: 30px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .toggle-btn {
            padding: 12px 25px;
            border: 2px solid rgba(255, 105, 180, 0.3);
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            color: rgba(255,255,255,0.7);
            border-radius: 30px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-btn:hover {
            border-color: rgba(255, 105, 180, 0.6);
            background: rgba(255, 105, 180, 0.1);
        }

        .toggle-btn.active {
            background: rgba(255, 105, 180, 0.2);
            border-color: #ff69b4;
            color: #ff69b4;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.3);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 380px;
            max-height: 65vh;
            background: rgba(10, 20, 40, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(255, 105, 180, 0.15);
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .panel-header {
            padding: 20px;
            background: linear-gradient(135deg, rgba(255, 105, 180, 0.15), rgba(255, 105, 180, 0.05));
            border-bottom: 1px solid rgba(255, 105, 180, 0.1);
        }

        .panel-header h2 {
            font-size: 1.3em;
            color: #ff69b4;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .part-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
        }

        .panel-body {
            padding: 20px;
            overflow-y: auto;
            max-height: 45vh;
        }

        .panel-body p {
            color: rgba(255,255,255,0.7);
            line-height: 1.7;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .function-box {
            background: rgba(46, 204, 113, 0.1);
            border-left: 3px solid #2ecc71;
            padding: 12px 15px;
            border-radius: 0 10px 10px 0;
            margin-bottom: 15px;
        }

        .function-box h4 {
            color: #2ecc71;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .function-box p {
            margin: 0;
            font-size: 0.85em;
        }

        .feature-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag {
            padding: 6px 14px;
            background: rgba(255, 105, 180, 0.1);
            border: 1px solid rgba(255, 105, 180, 0.2);
            border-radius: 20px;
            font-size: 0.75em;
            color: #ff69b4;
        }

        /* Controls hint */
        .controls-hint {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 0.8em;
            color: rgba(255,255,255,0.6);
            z-index: 100;
        }

        .controls-hint strong {
            color: #ff69b4;
        }

        /* Loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0a15 0%, #0a0a20 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 105, 180, 0.2);
            border-top-color: #ff69b4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: rgba(255,255,255,0.6);
            font-size: 0.9em;
        }

        /* Click indicator */
        .click-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 25px;
            background: rgba(255, 105, 180, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 105, 180, 0.3);
            border-radius: 30px;
            color: #ff69b4;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 200;
        }

        .click-indicator.visible {
            opacity: 1;
        }

        /* Legend Panel */
        .legend-panel {
            position: fixed;
            top: 100px;
            right: 30px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
        }

        .legend-title {
            color: #ff69b4;
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8em;
        }

        .legend-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .legend-item.active {
            background: rgba(255, 105, 180, 0.2);
        }

        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .info-panel {
                width: calc(100% - 40px);
                left: 20px;
                bottom: 20px;
                max-height: 40vh;
            }
            .legend-panel {
                display: none;
            }
            .controls-hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">3D-Bl√ºte wird geladen...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="header">
        <h1>üå∏ 3D Bl√ºten-Anatomie</h1>
        <p class="subtitle">Erkunde den Aufbau einer Bl√ºte in 3D</p>
    </div>

    <div class="view-toggle">
        <button class="toggle-btn active" id="fullBtn" onclick="setView('full')">üå∫ Vollst√§ndig</button>
        <button class="toggle-btn" id="crossBtn" onclick="setView('cross')">üî¨ Querschnitt</button>
    </div>

    <div class="legend-panel">
        <div class="legend-title">Bl√ºtenteile</div>
        <div class="legend-item" onclick="selectPart('petals')" data-part="petals">
            <div class="legend-dot" style="background: #e91e63;"></div>
            <span>Kronbl√§tter</span>
        </div>
        <div class="legend-item" onclick="selectPart('sepals')" data-part="sepals">
            <div class="legend-dot" style="background: #4caf50;"></div>
            <span>Kelchbl√§tter</span>
        </div>
        <div class="legend-item" onclick="selectPart('stamen')" data-part="stamen">
            <div class="legend-dot" style="background: #ffc107;"></div>
            <span>Staubbl√§tter</span>
        </div>
        <div class="legend-item" onclick="selectPart('pistil')" data-part="pistil">
            <div class="legend-dot" style="background: #9c27b0;"></div>
            <span>Stempel</span>
        </div>
        <div class="legend-item" onclick="selectPart('receptacle')" data-part="receptacle">
            <div class="legend-dot" style="background: #8bc34a;"></div>
            <span>Bl√ºtenboden</span>
        </div>
        <div class="legend-item" onclick="selectPart('stem')" data-part="stem">
            <div class="legend-dot" style="background: #689f38;"></div>
            <span>Bl√ºtenstiel</span>
        </div>
    </div>

    <div class="info-panel" id="infoPanel">
        <div class="panel-header">
            <h2>
                <span class="part-icon" id="partIcon" style="background: rgba(255,105,180,0.2);">üå∏</span>
                <span id="partName">Klicke auf einen Bl√ºtenteil</span>
            </h2>
        </div>
        <div class="panel-body">
            <p id="partDesc">Drehe die Bl√ºte mit der Maus und klicke auf die verschiedenen Teile, um mehr √ºber ihre Struktur und Funktion zu erfahren.</p>
            <div class="function-box" id="functionBox" style="display: none;">
                <h4>üéØ Funktion</h4>
                <p id="functionText"></p>
            </div>
            <div class="feature-tags" id="partTags"></div>
        </div>
    </div>

    <div class="controls-hint">
        <strong>üñ±Ô∏è Linksklick + Ziehen:</strong> Drehen<br>
        <strong>üîç Scrollrad:</strong> Zoom<br>
        <strong>üëÜ Klick auf Teil:</strong> Info anzeigen
    </div>

    <div class="click-indicator" id="clickIndicator">Klicke auf einen Bl√ºtenteil</div>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>

    <script>
        // Orbit controls inline
        class OrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3();
                this.enableDamping = true;
                this.dampingFactor = 0.05;
                this.rotateSpeed = 0.5;
                this.zoomSpeed = 1.0;
                this.minDistance = 4;
                this.maxDistance = 20;

                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                this.isMouseDown = false;
                this.prevMouse = { x: 0, y: 0 };

                this.init();
            }

            init() {
                const offset = new THREE.Vector3().copy(this.camera.position).sub(this.target);
                this.spherical.setFromVector3(offset);

                this.domElement.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    this.prevMouse = { x: e.clientX, y: e.clientY };
                });

                this.domElement.addEventListener('mousemove', (e) => {
                    if (!this.isMouseDown) return;
                    const deltaX = e.clientX - this.prevMouse.x;
                    const deltaY = e.clientY - this.prevMouse.y;
                    this.sphericalDelta.theta -= deltaX * 0.005 * this.rotateSpeed;
                    this.sphericalDelta.phi -= deltaY * 0.005 * this.rotateSpeed;
                    this.prevMouse = { x: e.clientX, y: e.clientY };
                });

                this.domElement.addEventListener('mouseup', () => this.isMouseDown = false);
                this.domElement.addEventListener('mouseleave', () => this.isMouseDown = false);

                this.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.spherical.radius += e.deltaY * 0.01 * this.zoomSpeed;
                    this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
                }, { passive: false });

                // Touch support
                this.domElement.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        this.isMouseDown = true;
                        this.prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                });

                this.domElement.addEventListener('touchmove', (e) => {
                    if (!this.isMouseDown || e.touches.length !== 1) return;
                    const deltaX = e.touches[0].clientX - this.prevMouse.x;
                    const deltaY = e.touches[0].clientY - this.prevMouse.y;
                    this.sphericalDelta.theta -= deltaX * 0.005 * this.rotateSpeed;
                    this.sphericalDelta.phi -= deltaY * 0.005 * this.rotateSpeed;
                    this.prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                });

                this.domElement.addEventListener('touchend', () => this.isMouseDown = false);
            }

            update() {
                this.spherical.theta += this.sphericalDelta.theta;
                this.spherical.phi += this.sphericalDelta.phi;
                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));

                if (this.enableDamping) {
                    this.sphericalDelta.theta *= (1 - this.dampingFactor);
                    this.sphericalDelta.phi *= (1 - this.dampingFactor);
                }

                const offset = new THREE.Vector3().setFromSpherical(this.spherical);
                this.camera.position.copy(this.target).add(offset);
                this.camera.lookAt(this.target);
            }
        }

        // Main application
        let scene, camera, renderer, controls;
        let viewMode = 'full';
        let flowerParts = [];
        let raycaster, mouse;
        let selectedPart = null;

        const partData = {
            petals: {
                name: 'Kronbl√§tter (Petalen)',
                icon: 'üå∫',
                color: 0xe91e63,
                desc: 'Die auff√§llig gef√§rbten, inneren Bl√ºtenbl√§tter. Sie bilden zusammen die Bl√ºtenkrone (Corolla). Ihre leuchtenden Farben und Muster sind oft nur f√ºr best√§ubende Insekten sichtbar (UV-Muster).',
                function: 'Locken Best√§uber (Bienen, Schmetterlinge, Hummeln) durch Farbe, Form, Duft und Nektarf√ºhrungszeichen an.',
                tags: ['Anlockung', 'Farbe', 'Duft', 'Corolla']
            },
            sepals: {
                name: 'Kelchbl√§tter (Sepalen)',
                icon: 'üåø',
                color: 0x4caf50,
                desc: 'Die √§u√üeren, meist gr√ºnen Bl√ºtenbl√§tter. Sie bilden den Kelch (Calyx), der die Bl√ºtenknospe vor dem √ñffnen umh√ºllt und sch√ºtzt.',
                function: 'Schutz der empfindlichen inneren Bl√ºtenteile w√§hrend der Knospenentwicklung vor Austrocknung, K√§lte und Fra√ü.',
                tags: ['Schutz', 'Kelch', 'Calyx', 'Knospe']
            },
            stamen: {
                name: 'Staubbl√§tter (Stamina)',
                icon: 'üåæ',
                color: 0xffc107,
                desc: 'Die m√§nnlichen Fortpflanzungsorgane der Bl√ºte. Jedes Staubblatt besteht aus dem Staubfaden (Filament) und dem Staubbeutel (Anthere), der den Pollen enth√§lt.',
                function: 'Produktion und Freisetzung von Pollen (m√§nnliche Keimzellen) zur Best√§ubung und Befruchtung.',
                tags: ['Pollen', 'M√§nnlich', 'Anthere', 'Filament']
            },
            pistil: {
                name: 'Stempel (Pistill)',
                icon: 'üíú',
                color: 0x9c27b0,
                desc: 'Das weibliche Fortpflanzungsorgan im Zentrum der Bl√ºte. Besteht aus der klebrigen Narbe (Stigma) oben, dem Griffel (Stylus) in der Mitte und dem Fruchtknoten (Ovar) mit den Samenanlagen unten.',
                function: 'Empfang des Pollens auf der Narbe, Pollenkeimung, Befruchtung der Samenanlagen und Samenentwicklung im Fruchtknoten.',
                tags: ['Weiblich', 'Narbe', 'Fruchtknoten', 'Samenanlage']
            },
            receptacle: {
                name: 'Bl√ºtenboden (Receptaculum)',
                icon: 'üü¢',
                color: 0x8bc34a,
                desc: 'Die verdickte, meist kegelf√∂rmige Basis der Bl√ºte, auf der alle Bl√ºtenorgane in einer bestimmten Reihenfolge entspringen.',
                function: 'Verbindet und tr√§gt alle Bl√ºtenteile. Bei manchen Fr√ºchten (z.B. Erdbeere, Apfel) wird er zum essbaren Teil der Frucht.',
                tags: ['Basis', 'Tr√§ger', 'Fruchtbildung']
            },
            stem: {
                name: 'Bl√ºtenstiel (Pedunculus)',
                icon: 'üå±',
                color: 0x689f38,
                desc: 'Der stabile, gr√ºne Stiel, der die Bl√ºte mit dem Hauptspross der Pflanze verbindet. Enth√§lt Leitb√ºndel f√ºr den Stofftransport.',
                function: 'Transport von Wasser, Mineralien und Assimilaten zur Bl√ºte. Positioniert die Bl√ºte optimal f√ºr Best√§uber.',
                tags: ['Transport', 'Verbindung', 'Leitb√ºndel']
            }
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 1, 0);

            // Raycaster for clicking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);

            const pinkLight = new THREE.PointLight(0xff69b4, 0.8, 15);
            pinkLight.position.set(-3, 5, 3);
            scene.add(pinkLight);

            const greenLight = new THREE.PointLight(0x4caf50, 0.5, 15);
            greenLight.position.set(3, -2, 3);
            scene.add(greenLight);

            // Create flower
            createFlower();

            // Add background particles
            createBackground();

            // Events
            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);

            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 800);

            // Start animation
            animate();
        }

        function createFlower() {
            // Clear previous parts
            flowerParts.forEach(p => {
                scene.remove(p);
                if (p.geometry) p.geometry.dispose();
                if (p.material) p.material.dispose();
            });
            flowerParts = [];

            const crossSection = viewMode === 'cross';

            // Stem
            createStem(crossSection);

            // Receptacle
            createReceptacle(crossSection);

            // Sepals
            createSepals(crossSection);

            // Petals
            createPetals(crossSection);

            // Stamen
            createStamen(crossSection);

            // Pistil
            createPistil(crossSection);
        }

        function createStem(crossSection) {
            const stemGroup = new THREE.Group();

            // Main stem
            const stemGeo = new THREE.CylinderGeometry(0.15, 0.2, 4, 16);
            const stemMat = new THREE.MeshPhysicalMaterial({
                color: 0x689f38,
                roughness: 0.6,
                metalness: 0.1,
                emissive: 0x2d5016,
                emissiveIntensity: 0.1
            });

            if (crossSection) {
                stemMat.transparent = true;
                stemMat.opacity = 0.8;
                stemMat.side = THREE.DoubleSide;
            }

            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = -2;
            stemGroup.add(stem);

            // Add subtle texture lines
            for (let i = 0; i < 5; i++) {
                const lineGeo = new THREE.CylinderGeometry(0.16, 0.21, 4, 4, 1, true, i * Math.PI / 2.5, 0.1);
                const lineMat = new THREE.MeshBasicMaterial({
                    color: 0x4a7c29,
                    transparent: true,
                    opacity: 0.5
                });
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.position.y = -2;
                stemGroup.add(line);
            }

            stemGroup.userData = { type: 'stem', data: partData.stem };
            scene.add(stemGroup);
            flowerParts.push(stemGroup);
        }

        function createReceptacle(crossSection) {
            const recGroup = new THREE.Group();

            // Receptacle (dome shape)
            const recGeo = new THREE.SphereGeometry(0.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const recMat = new THREE.MeshPhysicalMaterial({
                color: 0x8bc34a,
                roughness: 0.5,
                metalness: 0.1,
                emissive: 0x4a7c29,
                emissiveIntensity: 0.2
            });

            if (crossSection) {
                recMat.transparent = true;
                recMat.opacity = 0.7;
            }

            const receptacle = new THREE.Mesh(recGeo, recMat);
            receptacle.rotation.x = Math.PI;
            receptacle.position.y = 0;
            recGroup.add(receptacle);

            recGroup.userData = { type: 'receptacle', data: partData.receptacle };
            scene.add(recGroup);
            flowerParts.push(recGroup);
        }

        function createSepals(crossSection) {
            const sepalGroup = new THREE.Group();
            const numSepals = 5;

            for (let i = 0; i < numSepals; i++) {
                const angle = (i / numSepals) * Math.PI * 2;

                // Sepal shape (pointed oval)
                const sepalShape = new THREE.Shape();
                sepalShape.moveTo(0, 0);
                sepalShape.bezierCurveTo(0.3, 0.3, 0.3, 1.2, 0, 1.8);
                sepalShape.bezierCurveTo(-0.3, 1.2, -0.3, 0.3, 0, 0);

                const extrudeSettings = { depth: 0.05, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02, bevelSegments: 3 };
                const sepalGeo = new THREE.ExtrudeGeometry(sepalShape, extrudeSettings);

                const sepalMat = new THREE.MeshPhysicalMaterial({
                    color: 0x4caf50,
                    roughness: 0.6,
                    metalness: 0.1,
                    emissive: 0x2e7d32,
                    emissiveIntensity: 0.15,
                    side: THREE.DoubleSide
                });

                if (crossSection) {
                    sepalMat.transparent = true;
                    sepalMat.opacity = 0.6;
                }

                const sepal = new THREE.Mesh(sepalGeo, sepalMat);
                sepal.position.set(
                    Math.sin(angle) * 0.3,
                    -0.2,
                    Math.cos(angle) * 0.3
                );
                sepal.rotation.y = -angle;
                sepal.rotation.x = Math.PI / 2 + 0.5;

                sepalGroup.add(sepal);
            }

            sepalGroup.userData = { type: 'sepals', data: partData.sepals };
            scene.add(sepalGroup);
            flowerParts.push(sepalGroup);
        }

        function createPetals(crossSection) {
            const petalGroup = new THREE.Group();
            const numPetals = 5;

            for (let i = 0; i < numPetals; i++) {
                const angle = (i / numPetals) * Math.PI * 2 + Math.PI / 5;

                // Petal shape (heart-like)
                const petalShape = new THREE.Shape();
                petalShape.moveTo(0, 0);
                petalShape.bezierCurveTo(0.8, 0.5, 1.2, 2, 0.6, 3);
                petalShape.bezierCurveTo(0.3, 3.3, 0, 3.2, 0, 3);
                petalShape.bezierCurveTo(0, 3.2, -0.3, 3.3, -0.6, 3);
                petalShape.bezierCurveTo(-1.2, 2, -0.8, 0.5, 0, 0);

                const extrudeSettings = { depth: 0.03, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.03, bevelSegments: 5 };
                const petalGeo = new THREE.ExtrudeGeometry(petalShape, extrudeSettings);

                const petalMat = new THREE.MeshPhysicalMaterial({
                    color: 0xe91e63,
                    roughness: 0.3,
                    metalness: 0.1,
                    emissive: 0xad1457,
                    emissiveIntensity: 0.2,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: crossSection ? 0.5 : 0.95
                });

                const petal = new THREE.Mesh(petalGeo, petalMat);
                petal.position.set(
                    Math.sin(angle) * 0.5,
                    0.2,
                    Math.cos(angle) * 0.5
                );
                petal.rotation.y = -angle;
                petal.rotation.x = Math.PI / 2 - 0.3;

                // Add petal vein (center line)
                const veinGeo = new THREE.CylinderGeometry(0.01, 0.01, 2.5, 8);
                const veinMat = new THREE.MeshBasicMaterial({ color: 0xf48fb1, transparent: true, opacity: 0.6 });
                const vein = new THREE.Mesh(veinGeo, veinMat);
                vein.position.set(0, 1.3, 0.04);
                vein.rotation.x = Math.PI / 2;
                petal.add(vein);

                petalGroup.add(petal);
            }

            petalGroup.userData = { type: 'petals', data: partData.petals };
            scene.add(petalGroup);
            flowerParts.push(petalGroup);
        }

        function createStamen(crossSection) {
            const stamenGroup = new THREE.Group();
            const numStamen = 6;

            for (let i = 0; i < numStamen; i++) {
                const angle = (i / numStamen) * Math.PI * 2;
                const stamen = new THREE.Group();

                // Filament (thread)
                const filamentGeo = new THREE.CylinderGeometry(0.03, 0.04, 1.5, 8);
                const filamentMat = new THREE.MeshPhysicalMaterial({
                    color: 0xfff59d,
                    roughness: 0.4,
                    emissive: 0xf9a825,
                    emissiveIntensity: 0.2
                });

                if (crossSection) {
                    filamentMat.transparent = true;
                    filamentMat.opacity = 0.7;
                }

                const filament = new THREE.Mesh(filamentGeo, filamentMat);
                filament.position.y = 0.75;
                stamen.add(filament);

                // Anther (pollen sac)
                const antherGeo = new THREE.CapsuleGeometry(0.1, 0.25, 8, 16);
                const antherMat = new THREE.MeshPhysicalMaterial({
                    color: 0xffc107,
                    roughness: 0.3,
                    metalness: 0.2,
                    emissive: 0xf57f17,
                    emissiveIntensity: 0.3
                });

                if (crossSection) {
                    antherMat.transparent = true;
                    antherMat.opacity = 0.7;
                }

                const anther = new THREE.Mesh(antherGeo, antherMat);
                anther.position.y = 1.6;
                anther.rotation.z = Math.PI / 2;
                stamen.add(anther);

                stamen.position.set(
                    Math.sin(angle) * 0.4,
                    0.3,
                    Math.cos(angle) * 0.4
                );
                stamen.rotation.x = -0.2;
                stamen.rotation.z = -Math.sin(angle) * 0.15;
                stamenGroup.add(stamen);
            }

            stamenGroup.userData = { type: 'stamen', data: partData.stamen };
            scene.add(stamenGroup);
            flowerParts.push(stamenGroup);
        }

        function createPistil(crossSection) {
            const pistilGroup = new THREE.Group();

            // Ovary (base)
            const ovaryGeo = new THREE.SphereGeometry(0.35, 32, 32);
            const ovaryMat = new THREE.MeshPhysicalMaterial({
                color: 0x9c27b0,
                roughness: 0.4,
                metalness: 0.1,
                emissive: 0x7b1fa2,
                emissiveIntensity: 0.3
            });

            if (crossSection) {
                ovaryMat.transparent = true;
                ovaryMat.opacity = 0.6;

                // Show internal ovules
                for (let i = 0; i < 4; i++) {
                    const ovuleGeo = new THREE.SphereGeometry(0.08, 16, 16);
                    const ovuleMat = new THREE.MeshPhysicalMaterial({
                        color: 0xce93d8,
                        emissive: 0x9c27b0,
                        emissiveIntensity: 0.4
                    });
                    const ovule = new THREE.Mesh(ovuleGeo, ovuleMat);
                    ovule.position.set(
                        Math.sin(i * Math.PI / 2) * 0.15,
                        0.5 + (i % 2) * 0.1,
                        Math.cos(i * Math.PI / 2) * 0.15
                    );
                    pistilGroup.add(ovule);
                }
            }

            const ovary = new THREE.Mesh(ovaryGeo, ovaryMat);
            ovary.position.y = 0.5;
            pistilGroup.add(ovary);

            // Style (column)
            const styleGeo = new THREE.CylinderGeometry(0.08, 0.1, 1.2, 16);
            const styleMat = new THREE.MeshPhysicalMaterial({
                color: 0xba68c8,
                roughness: 0.3,
                emissive: 0x9c27b0,
                emissiveIntensity: 0.2
            });

            if (crossSection) {
                styleMat.transparent = true;
                styleMat.opacity = 0.7;
            }

            const style = new THREE.Mesh(styleGeo, styleMat);
            style.position.y = 1.35;
            pistilGroup.add(style);

            // Stigma (top - sticky surface)
            const stigmaGeo = new THREE.SphereGeometry(0.15, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const stigmaMat = new THREE.MeshPhysicalMaterial({
                color: 0xd500f9,
                roughness: 0.2,
                metalness: 0.3,
                emissive: 0xaa00ff,
                emissiveIntensity: 0.4
            });
            const stigma = new THREE.Mesh(stigmaGeo, stigmaMat);
            stigma.position.y = 2;
            pistilGroup.add(stigma);

            // Stigma details (papillae - sticky projections)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const papillaGeo = new THREE.CylinderGeometry(0.02, 0.01, 0.15, 6);
                const papilla = new THREE.Mesh(papillaGeo, stigmaMat);
                papilla.position.set(
                    Math.sin(angle) * 0.12,
                    2.05,
                    Math.cos(angle) * 0.12
                );
                papilla.rotation.x = Math.cos(angle) * 0.5;
                papilla.rotation.z = -Math.sin(angle) * 0.5;
                pistilGroup.add(papilla);
            }

            pistilGroup.userData = { type: 'pistil', data: partData.pistil };
            scene.add(pistilGroup);
            flowerParts.push(pistilGroup);
        }

        function createBackground() {
            // Floating pollen/particles
            const particlesGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            for (let i = 0; i < 500; i++) {
                positions.push(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50
                );

                // Mix of golden (pollen) and pink particles
                if (Math.random() > 0.5) {
                    colors.push(1, 0.8, 0.2); // Golden
                } else {
                    colors.push(1, 0.4, 0.7); // Pink
                }
            }

            particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particlesGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const particlesMat = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });

            const particles = new THREE.Points(particlesGeo, particlesMat);
            scene.add(particles);
        }

        function setView(view) {
            viewMode = view;
            document.getElementById('fullBtn').classList.toggle('active', view === 'full');
            document.getElementById('crossBtn').classList.toggle('active', view === 'cross');
            createFlower();

            // Reset selection
            selectedPart = null;
            document.getElementById('partName').textContent = 'Klicke auf einen Bl√ºtenteil';
            document.getElementById('partIcon').textContent = 'üå∏';
            document.getElementById('partDesc').textContent = view === 'cross'
                ? 'Querschnitt-Ansicht: Erkunde das Innere der Bl√ºte und die Samenanlagen im Fruchtknoten.'
                : 'Drehe die Bl√ºte und klicke auf die verschiedenen Teile, um mehr zu erfahren.';
            document.getElementById('functionBox').style.display = 'none';
            document.getElementById('partTags').innerHTML = '';
        }

        function selectPart(type) {
            const data = partData[type];
            if (!data) return;

            selectedPart = type;

            // Update legend highlighting
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.toggle('active', item.dataset.part === type);
            });

            // Update info panel
            document.getElementById('partName').textContent = data.name;
            document.getElementById('partIcon').textContent = data.icon;
            document.getElementById('partIcon').style.background = `rgba(${(data.color >> 16) & 255}, ${(data.color >> 8) & 255}, ${data.color & 255}, 0.3)`;
            document.getElementById('partDesc').textContent = data.desc;
            document.getElementById('functionBox').style.display = 'block';
            document.getElementById('functionText').textContent = data.function;
            document.getElementById('partTags').innerHTML = data.tags.map(tag => `<span class="tag">${tag}</span>`).join('');

            // Highlight the selected part in 3D
            flowerParts.forEach(part => {
                if (part.userData.type === type) {
                    // Add glow effect
                    part.traverse(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.5;
                        }
                    });
                } else {
                    part.traverse(child => {
                        if (child.material && child.material.emissiveIntensity !== undefined) {
                            child.material.emissiveIntensity = 0.15;
                        }
                    });
                }
            });
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(flowerParts, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;

                // Traverse up to find the group with userData
                while (obj && !obj.userData.type) {
                    obj = obj.parent;
                }

                if (obj && obj.userData.type) {
                    selectPart(obj.userData.type);
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(flowerParts, true);

            if (intersects.length > 0) {
                renderer.domElement.style.cursor = 'pointer';
                const indicator = document.getElementById('clickIndicator');
                indicator.classList.add('visible');
                setTimeout(() => indicator.classList.remove('visible'), 1500);
            } else {
                renderer.domElement.style.cursor = 'grab';
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            controls.update();

            // Subtle animation - gentle sway
            flowerParts.forEach((part, i) => {
                if (part.userData.type === 'petals') {
                    part.children.forEach((petal, j) => {
                        petal.rotation.x = Math.PI / 2 - 0.3 + Math.sin(time + j) * 0.02;
                    });
                }
                if (part.userData.type === 'stamen') {
                    part.children.forEach((stamen, j) => {
                        stamen.rotation.x = -0.2 + Math.sin(time * 1.5 + j) * 0.03;
                    });
                }
            });

            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
